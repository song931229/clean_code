<style>body {font-family: D2Coding;}</style>

# day1

## 복간에 부쳐

- 자매품 Clean Coder를 읽고 전문가 정신, 장인 정신에 대한 의문점 해결
- 오래된 책이기 때문에 유효하지 않은 충고가 있음
- 요즘엔 fluent interface<sup>[1](#1)</sup>가 등장 : TODO
- 책을 읽고 자괴감이 들었음.

---

<a name="1">fluent_interface</a>: 주석에 관한 설명을 이곳에...

## 옮긴이의 말

축약하면 체크아웃코드가 체크인코드보다 깨끗해야 할것이라 말한다.

책의 전반부에서는 클린코드에 대한 패턴을 수립하여 개념을 정리하고,

후반부에는 bad to clean을 비교하고, 사고흐름까지 확인하여 이해하고 응용

( 코드의 처음부터 끝까지 리팩터링을 제시)

-> 저자의 경험을 체험하고, 공감하며 최종적으로 clean code를 이해하는 것.

개념서처럼 반복적으로 읽고, 계속 참고하며, '올바른 코드'에 대한 가치관을 설립하길 바람

1) 메타포 : TODO

---

## 추천사

덴마크 속담 - 추후 첨부

: 사소한 곳에서 발휘하는 정직은 사소하지 않다

소프트웨어의 80% 이상은 '유지보수' 공수이다.

따라서, 제품을 찍어내는 것에 집중하는 것은 제품의 유지보수에 집중하는 것보다 비효율 적이다.

### 5S

> __정리__ - 올바른 명명법 [무엇이 어디에 있는가?]  
> ___정돈___ - 올바른 위치, 적절한 위치 [그것이 그곳에 있는가?]  
> ___청소___ - 주석을 감싼코드 (과겨이력, 반영할내용) [그곳에 그것만 >있는가?]  
> ___청결___ - 모두 혹은 집단과 동의한 약속(규칙,원칙) [무엇을 어디에 둘건가?]  
> ___생활화___ - 위 4S의 연속, 반복 [약속을 지키는가?]

[TMP 품질관리론](https://m.cafe.daum.net/yasungmi/LljJ/572)

- 제품에는 생명주기가 있고, 제품의 생산자는 이 점을 고려하여 어떠한 부분이 과잉되거나 결여되지 않도록 주의하여야한다.

'읽기 좋은 코드' & '작동하는 코드'  => IMPORTANT

크리스토퍼 알렉산더(패턴과 패턴언어의 아버지)

- "모든 설계는 국부적인 수리 행위이다. "

- "전체구조를 훌륭하게 만드는 것이 장인으로서 건축가가 유일하게 해야할 일이다. "

-> 주택의 형태는 거주자에게 맡김

대다수의 예술도 비슷하다.

"시란 영원히 미완성이라, 끝없는 재작없이 필요하며 포기할 때에만 끝난다" - 폴 발레리

위와같이 세세함에 몰두하는 태도는 탁월함을 추구하는 모든 노력에서 공통으로 발견

벨 연구소 소프트웨어 제조 연구소의 조사

일관적인 들여쓰기(indent) 스타일이 버그 수를 줄여주는 가장 중요한 용인 중 하나라고 추측.

[style-guide](https://cfss.uchicago.edu/notes/style-guide/)

Bugs and styling code | Computing for the Social Sciences
library(tidyverse) set.seed(1234) Admiral Grace Hopper discovered the first bug in a computer Run the code below in your console to download this exercise as a set of R scripts. usethis::use_course("uc-cfss/debugging-and-defensive-programming") A software bug is “an error, flaw, failure or fault in ...

cfss.uchicago.edu

TODO - 실재 스터디 찾아보기(위에것은 임시)

소위 전문가들은 고상한 설계 방법론과 도구에 통달해야한다고 말하며, 생각한다.

때문에, 들여쓰기(indent)에 가치를 더하는 것에 모욕을 느낀다.

이와 같은 태도의 차이가 탁월함과 능숙함을 구분짓는다.

품질은 하늘에서 뚝 떨어지는 것이 아니라, 사심없이 기울이는 무수한 관심에서 얻어진다.

"처음 왔을 때보다 캠프장을 더 깨끗이 치우고 떠나라"

0장.들어가면서

코드의 품질을 측정하는 척도 WTF/m - 분당 WTF(What The Fxxk)

장인 정신의 2단계

1.이론 - 원칙,패턴,기법,경험

2.실천 - 열심히 실행(연습)하여 몸과 마음으로 체득

자전거에대한 이론이 빠삭해도 자전거를 처음타는 사람이라면 100% 넘어진다.

(동의할 수 없는 여지가 있는 비유이긴함)

요지는 구현이라는 과정은 필연적으로 이론과 경험 혹은 실재기능이 필요하다는 것이다.

바로 나에게 스스로 대입하여, 클린코드에대한 이론만 알려주어서는 진실로 깨달을 수 없음으로,

코드를 많이 읽고, 많이 고치고, 많이 쓰고 반복하자.

책의 구성

1 원칙,패턴,실기

2 사례연구, 에제연습, 코드와 해설, 코드 변경의 목적, 이해, 납득

3 사례연구의 해설 (냄새와 휴리스틱), 생각묘사, 공감

휴리스틱(heuristic) : TODO

1장.개끗한 코드

- 좋은 코드와 나쁜 코드를 구분하는 능력

- 좋은 코드를 작성하는 능력

- 나쁜 코드를 좋은 코드로 바꾸는 능력

### 코드가 존재하리라

코드란 기계가 실행할 정도로 요구사항을 상세하게 명시하는 작업이다.

이를 '프로그래밍'이라 한다.

따라서, 어떤 언어를 사용하던지 코드는 기계가 이해하고 실행할 정도로 엄밀하고, 정확하고, 상세하고, 정형화되어야 한다.

좋은 코드는 가장 든든하며, 지지받고, 강조돼온 전제 중 하나이다.

### 나쁜 코드

앱 개발 -> 인기▲ -> 판매▲ -> 출시주기▲

출시에 바빠 코드를 마구 작성-> 나쁜코드로 이어짐

이전 버전의 버그가 다음 버전에도 그대로 남아 프로그램 시동시간▲, 프로그램 사망횟수▲

악화의 연속 -> 감당할수 없게되고 회사 망함

Implementation Patterns : TODO

나쁜코드를 경험하것을 고행(Wading)이라한다.

### 나쁜코드는 왜 생길까?

바빠서, 서두르다, 지겨워서, 다시 볼 여유가 없어서

나중에 다시 보리라 다짐하지만, 나중은 오지않는다 - 르브랑의 법칙

결국 쓰레기가 돌아감에 안도하고 안주하게 된다.

### 나쁜 코드의 대가

나쁜 코드는 개발속도를 크게 떨어뜨린다.

코드를 고칠 때마다 엉뚱한 곳에 문제가 추가적으로 발생하게되고, 때문에 시간이 더 소요되고 점점 악순환이된다

매번 얽히고 설킨 코드를 '해독'해서 얽히고 설킨 코드를 더함

n개로 이루어진 쓰레기 코드에 쓰레기 코드를 더함=> n+1번째 고칠 때는 n번째보다 더 많은 시간 소요

이는 생산성 저하로 이어짐.

관리직은 이를 인력투입으로 해결보려하고, 신규인력은 시스템 설계에대한 이해도가 낮아 더한 쓰레기코드를 추가하게되고, 생산성은 최악이된다.

그러면, 재설계를 요구하게되고, 결국엔 또 다른 쓰레기시스템을 만들고... 반복

결국에 깨끗한 코드는 효율성을 극대화하는 것으로 바람직한 개발자의 덕목

### 태도

좋은 코드를 사수하는 것은 프로그래머의 책임이다.

비유-의사에게 수술 전 손씻기를 지양하는 환자 -> 지식의 차이

의사의 의료지식 > 환자의 의료지식

환자의 말을 듣는 것은 어불성설

잘못된 인식!

나쁜 코드는 업무속도를 늦추지만, 빨리하려면 어쩔 수 없다.

No!

나쁜 코드는 업무속도를 늦추고, 빨리하려면 좋은 코드를 써야한다!

## 깨끗한 코드

### 깨끗한 코드란?

잘그린 그림과 깨끗한 코드는 크게 다르지않다. 대부분의 사람들이 그림을 볼 때, 그림이 잘 그려졌는지 엉망으로 그려졌느지 구분이 가능하다.

이처럼 코드도 보면 구분이 가능하다. 그러나, 좋은코드와 나쁜코드를 구분할 줄 안다고해서 좋은코드를 작성할 수 있는것은 아니다. 마치 그림을 구분할 수 있다고해서 그림을 잘 그리는게 아니듯이 말이다.

(요지는 알겠으나 이것도 동의하기 애매한 비유이긴하다)

## 코드감각

코드감각이 있다면 나쁜코드를 좋은코드로 바꾸는 능력이 있다는 것과 같다.

코드감각이 없다면 나쁜코드를 구분할 수는 있지만, 나쁜코드를 좋은코드로 바꿀 수는 없다.

## 깨끗한코드 말말말

- 우아하다 - 보기에 즐겁다

- 간단하다 - 명확한 목적, 복잡하지 않음

- 의존성이 낮다

- 성능 최적화는 무조건적이지 않고 원칙에 따른다

- 깨진창문이론을 토대로 깨진창문이 없어야한다

- 오류처리는 철저히 (메모리누수, 경쟁상태)

- 일관된 명명법

- 높은 표현력 (명명법)

- 높은 가독성

- (기능의) 자연스러운 연상

? 명쾌한 추상화 TODO

? 단순한 제어문 TODO

- API 최소화

? 코드는 문학적 - [문학적 프로그래밍](https://ko.wikipedia.org/wiki/%EB%AC%B8%ED%95%99%EC%A0%81_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)

- 노력과 정성이 느껴지고

- 완성도 혹은 완벽성 - 고치려고 살펴도 딱히 손댈 곳이 없음

- 모든 테스트를 통과

- 중복이 없음

- 클래스, 메서드, 함수 최소화

-> 중복줄이기, 표현력 높이기, 간단한 추상화 고려

## 저자의 생각

{이미지}

코드를 읽는시간 : 코드를 짜는 시간 = 10 : 1

코드를 짤 때 코드를 읽는 시간으로 대부분의 시간을 소모하니

코드를 읽는 효율이 높을 수록 생산성이 높아지게된다

따라서, 생산성이 높기위해서는 좋은 코드를 작성해야하고, 좋은 코드를 유지해야하고, 좋은 코드를 보수해야한다

day1 마무리

이 책의 전반적인 구성을 알게되었고, 저자가 책을 통해 이루려는 목표를 공감하게 되었다.

내가 코딩을 할 때, 느꼇던 점을 공감하고, 내가 했던 행동들이나 내가 일해온 방향성에대해 칭찬을 들은것같은 기분도든다.

이책을 읽고 내가 지향하는 나의 클린코드를 정립하여 각 언어를 사용할 때, 사용할 나만의 표준체계를 각 언어의 프로젝트마다 넣어둘 작정이다.

이것으로 Day1을 마친다.
